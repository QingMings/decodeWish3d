var _0x34b6 = ["FXAAShader", "\n", "join", "varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}", "uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "#define FXAA_REDUCE_MIN   (1.0/128.0)", "#define FXAA_REDUCE_MUL   (1.0/8.0)", "#define FXAA_SPAN_MAX     8.0", "vec3 rgbNW = texture2D( tDiffuse, ( vUv - resolution )).xyz;", "vec3 rgbNE = texture2D( tDiffuse, ( vUv + vec2( resolution.x, -resolution.y ) )).xyz;",
    "vec3 rgbSW = texture2D( tDiffuse, ( vUv + vec2( -resolution.x, resolution.y ) )).xyz;", "vec3 rgbSE = texture2D( tDiffuse, ( vUv + resolution )).xyz;", "vec4 rgbaM  = texture2D( tDiffuse,  vUv );", "vec3 rgbM  = rgbaM.xyz;", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float lumaNW = dot( rgbNW, luma );", "float lumaNE = dot( rgbNE, luma );", "float lumaSW = dot( rgbSW, luma );", "float lumaSE = dot( rgbSE, luma );", "float lumaM  = dot( rgbM,  luma );", "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
    "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );", "vec2 dir;", "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));", "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));", "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );", "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );", "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),", "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),", "dir * rcpDirMin)) * resolution;",
    "vec4 rgbA = (1.0/2.0) * (", "texture2D(tDiffuse,  vUv + dir * (1.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  vUv+ dir * (2.0/3.0 - 0.5)));", "vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (", "texture2D(tDiffuse,  vUv + dir * (0.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  vUv + dir * (3.0/3.0 - 0.5)));", "float lumaB = dot(rgbB, vec4(luma, 0.0));", "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {", "gl_FragColor = rgbA;", "} else {", "gl_FragColor = rgbB;", "SMAAShader", "0.1", "varying vec4 vOffset[ 3 ];",
    "void SMAAEdgeDetectionVS( vec2 texcoord ) {", "vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );", "vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );", "vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );", "SMAAEdgeDetectionVS( vUv );", "vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {", "vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );", "vec4 delta;", "vec3 C = texture2D( colorTex, texcoord ).rgb;",
    "vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;", "vec3 t = abs( C - Cleft );", "delta.x = max( max( t.r, t.g ), t.b );", "vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;", "t = abs( C - Ctop );", "delta.y = max( max( t.r, t.g ), t.b );", "vec2 edges = step( threshold, delta.xy );", "if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )", "discard;", "vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;", "t = abs( C - Cright );", "delta.z = max( max( t.r, t.g ), t.b );", "vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;",
    "t = abs( C - Cbottom );", "delta.w = max( max( t.r, t.g ), t.b );", "float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );", "vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;", "t = abs( C - Cleftleft );", "vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;", "t = abs( C - Ctoptop );", "maxDelta = max( max( maxDelta, delta.z ), delta.w );", "edges.xy *= step( 0.5 * maxDelta, delta.xy );", "return vec4( edges, 0.0, 0.0 );", "gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );",
    "8", "16", "( 1.0 / vec2( 160.0, 560.0 ) )", "( 1.0 / 7.0 )", "varying vec2 vPixcoord;", "void SMAABlendingWeightCalculationVS( vec2 texcoord ) {", "vPixcoord = texcoord / resolution;", "vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );", "vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );", "vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );",
    "SMAABlendingWeightCalculationVS( vUv );", "#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )", "uniform sampler2D tArea;", "uniform sampler2D tSearch;", "varying vec4 vOffset[3];", "vec2 round( vec2 x ) {", "return sign( x ) * floor( abs( x ) + 0.5 );", "float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {", "e.r = bias + e.r * scale;", "return 255.0 * texture2D( searchTex, e, 0.0 ).r;", "float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "vec2 e = vec2( 0.0, 1.0 );", "for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", "e = texture2D( edgesTex, texcoord, 0.0 ).rg;", "texcoord -= vec2( 2.0, 0.0 ) * resolution;", "if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;", "texcoord.x += 0.25 * resolution.x;", "texcoord.x += resolution.x;", "texcoord.x += 2.0 * resolution.x;", "texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);", "return texcoord.x;", "float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "texcoord += vec2( 2.0, 0.0 ) * resolution;", "if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;", "texcoord.x -= 0.25 * resolution.x;", "texcoord.x -= resolution.x;", "texcoord.x -= 2.0 * resolution.x;", "texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );", "float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {", "vec2 e = vec2( 1.0, 0.0 );", "texcoord += vec2( 0.0, 2.0 ) * resolution;", "if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
    "texcoord.y -= 0.25 * resolution.y;", "texcoord.y -= resolution.y;", "texcoord.y -= 2.0 * resolution.y;", "texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );", "return texcoord.y;", "float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {", "texcoord -= vec2( 0.0, 2.0 ) * resolution;", "if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;", "texcoord.y += 0.25 * resolution.y;", "texcoord.y += resolution.y;", "texcoord.y += 2.0 * resolution.y;",
    "texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );", "vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {", "vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;", "texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );", "texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;", "return texture2D( areaTex, texcoord, 0.0 ).rg;", "vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {",
    "vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );", "vec2 e = texture2D( edgesTex, texcoord ).rg;", "if ( e.g > 0.0 ) {", "vec2 d;", "vec2 coords;", "coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );", "coords.y = offset[ 1 ].y;", "d.x = coords.x;", "float e1 = texture2D( edgesTex, coords, 0.0 ).r;", "coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );", "d.y = coords.x;", "d = d / resolution.x - pixcoord.x;", "vec2 sqrt_d = sqrt( abs( d ) );",
    "coords.y -= 1.0 * resolution.y;", "float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;", "weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );", "if ( e.r > 0.0 ) {", "coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );", "coords.x = offset[ 0 ].x;", "d.x = coords.y;", "float e1 = texture2D( edgesTex, coords, 0.0 ).g;", "coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );", "d.y = coords.y;",
    "d = d / resolution.y - pixcoord.y;", "float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;", "weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );", "return weights;", "gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );", "varying vec4 vOffset[ 2 ];", "void SMAANeighborhoodBlendingVS( vec2 texcoord ) {", "vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );", "vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );",
    "SMAANeighborhoodBlendingVS( vUv );", "uniform sampler2D tColor;", "vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {", "vec4 a;", "a.xz = texture2D( blendTex, texcoord ).xz;", "a.y = texture2D( blendTex, offset[ 1 ].zw ).g;", "a.w = texture2D( blendTex, offset[ 1 ].xy ).a;", "if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {", "return texture2D( colorTex, texcoord, 0.0 );", "vec2 offset;", "offset.x = a.a > a.b ? a.a : -a.b;", "offset.y = a.g > a.r ? -a.g : a.r;",
    "if ( abs( offset.x ) > abs( offset.y )) {", "offset.y = 0.0;", "offset.x = 0.0;", "vec4 C = texture2D( colorTex, texcoord, 0.0 );", "texcoord += sign( offset ) * resolution;", "vec4 Cop = texture2D( colorTex, texcoord, 0.0 );", "float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );", "C.xyz = pow(C.xyz, vec3(2.2));", "Cop.xyz = pow(Cop.xyz, vec3(2.2));", "vec4 mixed = mix(C, Cop, s);", "mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));", "return mixed;", "gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );",
    "CopyShader", "uniform float opacity;", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "EffectComposer", "renderer", "LinearFilter", "RGBAFormat", "getSize", "width", "height", "renderTarget1", "renderTarget2", "clone", "writeBuffer", "readBuffer", "passes", "THREE.EffectComposer relies on THREE.CopyShader", "error", "copyPass", "prototype", "push", "setSize", "splice", "length", "enabled", "render", "needsSwap", "context", "stencilFunc", "swapBuffers", "MaskPass",
    "ClearMaskPass", "dispose", "assign", "Pass", "clear", "renderToScreen", "THREE.Pass: .render() must be implemented in derived pass.", "call", "scene", "camera", "inverse", "create", "state", "setMask", "color", "buffers", "depth", "setLocked", "setTest", "stencil", "setOp", "setFunc", "setClear", "RenderPass", "overrideMaterial", "clearColor", "clearAlpha", "autoClear", "getHex", "getClearColor", "getClearAlpha", "setClearColor", "ShaderPass", "textureID", "tDiffuse", "ShaderMaterial", "uniforms",
    "material", "UniformsUtils", "defines", "vertexShader", "fragmentShader", "quad", "add", "value", "texture", "OutlinePass", "renderScene", "renderCamera", "selectedObjects", "visibleEdgeColor", "hiddenEdgeColor", "edgeGlow", "usePatternTexture", "edgeThickness", "edgeStrength", "downSampleRatio", "pulsePeriod", "resolution", "x", "y", "round", "maskBufferMaterial", "side", "DoubleSide", "renderTargetMaskBuffer", "generateMipmaps", "depthMaterial", "depthPacking", "RGBADepthPacking", "blending", "NoBlending",
    "prepareMaskMaterial", "getPrepareMaskMaterial", "renderTargetDepthBuffer", "renderTargetMaskDownSampleBuffer", "renderTargetBlurBuffer1", "renderTargetBlurBuffer2", "edgeDetectionMaterial", "getEdgeDetectionMaterial", "renderTargetEdgeBuffer1", "renderTargetEdgeBuffer2", "separableBlurMaterial1", "getSeperableBlurMaterial", "texSize", "kernelRadius", "separableBlurMaterial2", "overlayMaterial", "getOverlayMaterial", "THREE.OutlinePass relies on THREE.CopyShader", "copyUniforms", "opacity", "materialCopy",
    "oldClearColor", "oldClearAlpha", "tempPulseColor1", "tempPulseColor2", "textureMatrix", "Mesh", "visible", "traverse", "id", "bVisible", "set", "projectionMatrix", "multiply", "matrixWorldInverse", "copy", "disable", "changeVisibilityOfSelectedObjects", "updateTextureMatrix", "changeVisibilityOfNonSelectedObjects", "background", "cameraNearFar", "near", "far", "depthTexture", "now", "cos", "multiplyScalar", "maskTexture", "colorTexture", "direction", "BlurDirectionX", "BlurDirectionY", "edgeTexture1",
    "edgeTexture2", "patternTexture", "enable", "varying vec2 vUv;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}",
    "#include <packing>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = -perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\t\t\t\t}",
    "varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}", "varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\t\t\t\t\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}",
    "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\t\t\t\t\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}",
    "varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}",
    "AdditiveBlending", "undefined", "object", "exports", "global", "window", "-", "Overflow: input needs wider integers to process", "Illegal input >= 0x80 (not a basic code point)", "Invalid input", "floor", "fromCharCode", ".", "split", "charCodeAt", "", "lastIndexOf", "not-basic", "invalid-input", "overflow", "test", "toLowerCase", "slice", "xn--", "1.2.4", "function", "amd", "punycode", "nodeType", "hasOwnProperty", "./log", "defaultView", "pageXOffset", "pageYOffset", "scrollTo", "getImageData",
    "2d", "getContext", "putImageData", "Unable to copy canvas content from", "nodeValue", "createTextNode", "cloneNode", "firstChild", "nodeName", "SCRIPT", "appendChild", "nextSibling", "_scrollTop", "scrollTop", "_scrollLeft", "scrollLeft", "CANVAS", "TEXTAREA", "SELECT", "documentElement", "javascriptEnabled", "iframe", "createElement", "className", "html2canvas-container", "visibility", "style", "hidden", "position", "fixed", "left", "-10000px", "top", "0px", "border", "0", "scrolling", "no", "body",
    "document", "contentWindow", "onload", "childNodes", "type", "view", "userAgent", "scrollY", "scrollX", "px", "absolute", "open", "<!DOCTYPE html><html></html>", "write", "adoptNode", "replaceChild", "close", "r", "g", "b", "a", "fromArray", "namedColor", "rgb", "rgba", "hex6", "hex3", "darken", "isTransparent", "isBlack", "isArray", "min", "match", "substring", "toString", "rgba(", ",", ")", "rgb(", "transparent", "isColor", "./support", "./renderers/canvas", "./imageloader", "./nodeparser", "./nodecontainer",
    "./utils", "./clone", "loadUrlDocument", "./proxy", "getBounds", "data-html2canvas-node", "logging", "options", "start", "async", "allowTaint", "removeContainer", "imageTimeout", "strict", "string", "proxy", "Proxy must be used when rendering url", "reject", "innerWidth", "innerHeight", "then", "setAttribute", "onrendered", "options.onrendered is deprecated, html2canvas returns a Promise containing the canvas", "ownerDocument", "CanvasRenderer", "NodeContainer", "log", "utils", "canvas", "No canvas support",
    "html2canvas", "Document cloned", "[", "='", "']", "removeAttribute", "querySelector", "onclone", "resolve", "Finished rendering", "ready", "removeChild", "parentNode", "Cleaned up container", "max", "Cropping canvas at:", "left:", "top:", "width:", "height:", "Resulting crop with width", "and height", "with x", "and y", "drawImage", "scrollWidth", "offsetWidth", "clientWidth", "scrollHeight", "offsetHeight", "clientHeight", "href", "smallImage", "src", "DummyImageContainer for", "promise", "image",
    "Initiating DummyImageContainer", "onerror", "complete", "div", "img", "span", "Hidden Text", "fontFamily", "fontSize", "margin", "padding", "verticalAlign", "baseline", "offsetTop", "lineHeight", "normal", "super", "lineWidth", "middle", "./font", "data", "getMetrics", "./core", "proxyLoad", "URL", "about:blank", "colorStops", "x0", "y0", "x1", "y1", "TYPES", "REGEXP_COLORSTOP", "tainted", "crossOrigin", "anonymous", "./imagecontainer", "./dummyimagecontainer", "./proxyimagecontainer", "./framecontainer",
    "./svgcontainer", "./svgnodecontainer", "./lineargradientcontainer", "./webkitgradientcontainer", "bind", "link", "support", "origin", "location", "getOrigin", "findImages", "loadImage", "addImage", "forEach", "node", "url", "concat", "IMG", "svg", "IFRAME", "reduce", "findBackgroundImage", "hasImageBackground", "filter", "parseBackgroundImages", "imageExists", "Added image #", "args", "method", "none", "isSVG", "replace", "isSameOrigin", "cors", "useCORS", "linear-gradient", "gradient", "isInline",
    "some", "protocol", "hostname", "port", "getPromise", "catch", "timeout", "get", "images", "fetch", "Succesfully loaded image #", "Failed loading image #", "map", "all", "Finished searching images", "Timed out loading image", "race", "./gradientcontainer", "./color", "apply", "LINEAR", "REGEXP_DIRECTION", "right", "bottom", "to", "center", "reverse", "%", "stop", "console", "ms", "html2canvas:", "parseBackgrounds", "offsetBounds", "parent", "stack", "bounds", "borders", "clip", "backgroundClip",
    "computedStyles", "colors", "styles", "backgroundImages", "transformData", "transformMatrix", "isPseudoElement", "cloneTo", "getOpacity", "cssFloat", "assignStack", "children", "isElementVisible", "TEXT_NODE", "display", "css", "data-html2canvas-ignore", "hasAttribute", "INPUT", "getAttribute", "before", ":before", ":after", "computedStyle", "prefixedCss", "webkit", "moz", "o", "toUpperCase", "substr", "getComputedStyle", "cssInt", "fontWeight", "bold", "parseClip", "backgroundImage", "cssList",
    "auto", " ", "trim", "parseBackgroundSize", "backgroundSize", "contain", "parseBackgroundPosition", "backgroundPosition", "parseBackgroundRepeat", "backgroundRepeat", "parseTextShadows", "textShadow", "parseTransform", "hasTransform", "parseBounds", "transformOrigin", "parseTransformMatrix", "transform", "1,0,0,1,0,0", "getValue", "tagName", "password", "\u2022", "placeholder", "MATRIX_PROPERTY", "TEXT_SHADOW_PROPERTY", "TEXT_SHADOW_VALUES", "CLIP", "selectedIndex", "text", "matrix", "matrix3d",
    "indexOf", "./textcontainer", "./pseudoelementcontainer", "./fontmetrics", "./stackingcontext", "Starting NodeParser", "range", "renderQueue", "rectangle", "backgroundColor", "visibile", "createPseudoHideStyles", "disableAnimations", "nodes", "getPseudoElements", "getChildren", "fontMetrics", "Fetched nodes, total:", "Calculate overflow clips", "calculateOverflowClips", "Start fetching images", "Images loaded, starting parsing", "Creating stacking contexts", "createStackingContexts", "Sorting stacking contexts",
    "sortStackingContexts", "parse", "Render queue created with ", " items", "paint", "renderIndex", "asyncRenderer", "appendToDOM", "parseBorders", "rect", "cleanDOM", "PSEUDO_HIDE_ELEMENT_CLASS_BEFORE", ':before { content: "" !important; display: none !important; }', "PSEUDO_HIDE_ELEMENT_CLASS_AFTER", ':after { content: "" !important; display: none !important; }', "createStyles", "* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ",
    "-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}", "innerHTML", "ELEMENT_NODE", "getPseudoElement", "content", "-moz-alt-content", "html2canvaspseudoelement", "item", "newStackingContext", "getParentStack", "contexts", "isRootElement", "isBodyWithTransparentRoot", "BODY", "sort", "parseTextBounds", "textDecoration", "rangeBounds", "getRangeBounds", "splitText", "getWrapperBounds", "html2canvaswrapper", "createRange",
    "setStart", "setEnd", "getBoundingClientRect", "restore", "ctx", "paintText", "paintNode", "setOpacity", "save", "setTransform", "checkbox", "paintCheckbox", "radio", "paintRadio", "paintElement", "renderBackground", "renderBorders", "renderImage", "Error loading <", ">", "Error loading <img>", "paintFormValue", "#A5A5A5", "#DEDEDE", "checked", "#424242", "arial", "font", "\u2714", "circleStroke", "ceil", "circle", "textAlign", "paddingLeft", "paddingTop", "paddingRight", "paddingBottom", "borderLeftStyle",
    "borderTopStyle", "borderLeftWidth", "borderTopWidth", "boxSizing", "whiteSpace", "wordWrap", "html2canvas: Parse: Exception caught in renderFormValue: ", "message", "textContent", "applyTextTransform", "decode", "ucs2", "letterRendering", "encode", "fontStyle", "fontVariant", "offsetX", "offsetY", "blur", "fontShadow", "clearShadow", "renderTextDecoration", "underline", "overline", "line-through", "Style", "Color", "inset", "Width", "Top", "Right", "Bottom", "Left", "parseBackgroundClip", "topLeftOuter",
    "topLeftInner", "topRightOuter", "topRightInner", "bottomRightOuter", "bottomRightInner", "bottomLeftOuter", "bottomLeftInner", "content-box", "padding-box", "sqrt", "subdivide", "topLeft", "topRight", "bottomRight", "bottomLeft", "bezierCurve", "line", "curveTo", "c1", "end", "curveToReversed", "c2", "c3", "c4", "zIndex", "inline", "inline-block", "inline-table", "letterSpacing", "Radius", "TopLeft", "TopRight", "BottomRight", "BottomLeft", "relative", "static", "float", "HEAD", "TITLE", "OBJECT",
    "BR", "OPTION", "./xhr", "decode64", "withCredentials", "No proxy configured", "data:", ";base64,", "script", "html2canvas_", "_", "random", "?url=", "&callback=html2canvas.proxy.", "text/html", "parseFromString", "DOMParser not supported, falling back to createHTMLDocument", "createHTMLDocument", "implementation", "createHTMLDocument write not supported, falling back to document.body.innerHTML", "base", "host", "head", "insertBefore", "Proxy", "ProxyURL", "Anonymous", "getHideClass", "PSEUDO_HIDE_ELEMENT_CLASS_",
    "BEFORE", "AFTER", "___html2canvas___pseudoelement_before", "___html2canvas___pseudoelement_after", "renderBackgroundColor", "renderBackgroundImage", "renderBorder", "drawShape", "renderBackgroundRepeating", "Error loading background-image", "renderBackgroundGradient", "Unknown background-image type", "repeat-x", "backgroundRepeatShape", "repeat no-repeat", "repeat-y", "no-repeat repeat", "no-repeat", "renderBackgroundRepeat", "../renderer", "../lineargradientcontainer", "../log", "taintCtx", "textBaseline",
    "variables", "Initialized CanvasRenderer with size", "setFillStyle", "fillStyle", "fillRect", "beginPath", "PI", "arc", "closePath", "fill", "strokeStyle", "stroke", "shape", "taints", "moveTo", "To", "shadowBlur", "setVariable", "shadowOffsetX", "shadowOffsetY", "shadowColor", "rgba(0,0,0,0)", "globalAlpha", "translate", "fillText", "resizeImage", "repeat", "createPattern", "createLinearGradient", "addColorStop", "ownStacking", "testRangeBounds", "testCORS", "testSVG", "boundtest", "123px", "block",
    "selectNode", "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>", "toDataURL", "createCanvas", "loadSVGFromString", "fabric", "inlineFormatting", "hasFabric", "html2canvas.svg.js is not loaded, cannot render svg", "removeContentType", "c", "lowerCanvasEl", "renderAll", "groupSVGElements", "util", "setHeight", "setWidth", "atob", "data:image/svg+xml,", "serializeToString", "parseSVGDocument", "textTransform", "lowercase", "capitalize", "uppercase", "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", "offsetParent", "offsetLeft", " \r\n\t", '"', "(", "linear", "RADIAL", "GET", "status", "responseText", "statusText", "Network Error", "send", "Cannot find module '", "'", "code", "MODULE_NOT_FOUND", "MTLLoader", "manager", "DefaultLoadingManager", "EventDispatcher", "path", "setPath", "load", "texturePath", "THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.",
    "warn", "setTexturePath", "materialOptions", "charAt", "#", "newmtl", "ka", "kd", "ks", "setCrossOrigin", "setManager", "setMaterials", "MaterialCreator", "baseUrl", "materialsInfo", "materials", "materialsArray", "nameLookup", "FrontSide", "wrap", "RepeatWrapping", "convert", "normalizeRGB", "ignoreZeroRGBs", "createMaterial_", "getTextureParams", "loadTexture", "scale", "offset", "wrapS", "wrapT", "specular", "map_kd", "specularMap", "map_ks", "map_bump", "bumpMap", "bump", "shininess", "ns", "d",
    "Tr", "-bm", "bumpScale", "-s", "-o", "Handlers", "Loader", "mapping", "OBJLoader", "regexp", "fromDeclaration", "name", "currentMaterial", "_finalize", "inherited", "groupCount", "index", "smooth", "groupEnd", "number", "mtllib", "vertices", "geometry", "groupStart", "objects", "normals", "uvs", "parseVertexIndex", "addVertex", "parseUVIndex", "addUV", "parseNormalIndex", "addNormal", "Line", "addVertexLine", "addUVLine", "startObject", "time", "\r\n", "\\\n", "trimLeft", "v", "exec", "vertex_pattern",
    "n", "normal_pattern", "t", "uv_pattern", "Unexpected vertex/normal/uv line: '", "f", "face_vertex_uv_normal", "addFace", "face_vertex_uv", "face_vertex_normal", "face_vertex", "Unexpected face line: '", "l", "/", "addLineGeometry", "object_pattern", "material_use_pattern", "materialLibraries", "startMaterial", "material_library_pattern", "smoothing_pattern", "1", "on", "\x00", "Unexpected line: '", "finalize", "addAttribute", "computeVertexNormals", "uv", "LineBasicMaterial", "shading", "SmoothShading",
    "FlatShading", "addGroup", "timeEnd", "constructor", "intersection", "DDSLoader", "_parser", "CompressedTextureLoader", "DXT1", "DXT3", "DXT5", "ETC1", "THREE.DDSLoader.parse: Invalid magic number in DDS header.", "THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.", "format", "RGB_S3TC_DXT1_Format", "RGBA_S3TC_DXT3_Format", "RGBA_S3TC_DXT5_Format", "RGB_ETC1_Format", "THREE.DDSLoader.parse: Unsupported FourCC code ", "mipmapCount", "isCubemap", "THREE.DDSLoader.parse: Incomplete cubemap faces",
    "mipmaps", "PVRLoader", "[THREE.PVRLoader] Unknown PVR format", "_parseV3", "header", "RGB_PVRTC_2BPPV1_Format", "RGBA_PVRTC_2BPPV1_Format", "RGB_PVRTC_4BPPV1_Format", "RGBA_PVRTC_4BPPV1_Format", "pvrtc - unsupported PVR format ", "dataPtr", "bpp", "numSurfaces", "numMipmaps", "_parseV2", "pvrtc - unknown format ", "_extract", "buffer", "appName", "navigator", "appVersion", "language", "appCodeName", "platform", "guid=", "&url=", "&type=1", "result", "POST", "http://www.wish3d.com/license/getLicenseState.action",
    "Content-type", "application/x-www-form-urlencoded", "setRequestHeader", "onreadystatechange", "readyState", "../license/getHardwareComputerID.action", "quaternion", "getPosition", "setPosition", "getQuaternion", "setQuaternion", "cameraKeys", "looptime", "vectorKeyframeTrack", "quaternionKeyframeTrack", "interpolant", "quaInterpolant", "bPause", "startTime", "pauseTime", "init", "toArray", "flytoCamera", "createInterpolant", "flyToCamera", "getAllKeys", "play", "pause", "update", "evaluate", "updateMatrixWorld",
    "createBuffer", "bindBuffer", "bufferData", "getAttribLocation", "uvOffset", "getUniformLocation", "uvScale", "rotation", "modelViewMatrix", "alphaTest", "white", "needsUpdate", "billboards", "useProgram", "initAttributes", "disableUnusedAttributes", "elements", "uniformMatrix4fv", "activeTexture", "uniform1i", "fogType", "matrixWorld", "multiplyMatrices", "z", "getScreenRect", "geoParent", "GeoLabel", "iconPath", "setNameVisble", "attributes", "itemSize", "getAttributeBuffer", "enableAttribute",
    "vertexAttribPointer", "uniform1f", "decompose", "uniform2f", "uniform3f", "uniform2fv", "blendEquation", "blendSrc", "blendDst", "setBlending", "depthTest", "setDepthTest", "depthWrite", "setDepthWrite", "setTexture", "drawElements", "resetGLState", "createProgram", "createShader", "precision ", "getPrecision", " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;",
    "attribute vec2 uv;", "varying vec2 vUV;", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;",
    "gl_Position = finalPosition;", "shaderSource", "uniform vec3 color;", "uniform sampler2D map;", "uniform float alphaTest;", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "compileShader", "attachShader", "linkProgram", "Object3D", "verticalOrign", "horizontalOrigin", "vA", "vB", "vC", "vD", "setIndex", "LSJBillboard", "raycast", "applyMatrix4", "intersectTriangle", "ray", "Er", "us", "ensurePowerOfTwo_",
    "isPowerOfTwo", "Math", "nextHighestPowerOfTwo_", "preDealPath", "\\", "//", "http:", "http://", "getDir", "getAbsolutePath", "./", ".\\", "../", "..\\", ":", "\\\\", "createXMLHttp", "XMLHttpRequest", "Microsoft.XMLHTTP", "\u60a8\u7684\u6d4f\u89c8\u5668\u4e0d\u652f\u6301\u89e3\u6790xml", "createXMLDom", "MSXML2.DOMDocument.5.0", "MSXML2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "Microsoft.XMLDOM", "MSXML.DOMDocument", "createDocument", "Bold ", "getFontSize", "px ", "getFontName",
    "getStrokeWidth", "lineJoin", "computedWidth", "maxx", "minx", "dimensions", "ascent", "getStyle", "getOutlineColor", "strokeText", "getFillColor", "getPropertyValue", "measureText", "font-family", "font-size", "fontsize", "<br/>", "leading", "black", "descent", "tan", "DragControls", "off", "setObjects", "Scene", "activate", "mousemove", "addEventListener", "mousedown", "mouseup", "deactivate", "removeEventListener", "preventDefault", "clientX", "clientY", "setFromCamera", "dot", "no or infinite solutions",
    "sub", "point", "drag", "intersectObjects", "cursor", "pointer", "hoveron", "hoveroff", "move", "dragstart", "dragend", "layers", "meshGroup", "boundingSphere", "remove", "addLayer", "getBoundingSphere", "expandSphere", "getLayerByCaption", "caption", "getLayerByName", "getLayerByIndex", "empty", "releaseSelection", "FeatureLayer", "RenderableObject", "renderOrder", "RenderableFace", "v1", "v2", "v3", "normalModel", "vertexNormalsModel", "vertexNormalsLength", "RenderableVertex", "positionWorld",
    "positionScreen", "RenderableLine", "vertexColors", "RenderableSprite", "Projector", "projectVector", "THREE.Projector: .projectVector() is now vector.project().", "project", "unprojectVector", "THREE.Projector: .unprojectVector() is now vector.unproject().", "unproject", "pickingRay", "THREE.Projector: .pickingRay() is now raycaster.setFromCamera().", "getNormalMatrix", "w", "setFromPoints", "isIntersectionBox", "normalize", "applyMatrix3", "projectScene", "autoUpdate", "getInverse", "setFromMatrix",
    "lights", "Light", "Sprite", "frustumCulled", "intersectsObject", "setFromMatrixPosition", "applyProjection", "traverseVisible", "setObject", "BufferGeometry", "groups", "array", "pushVertex", "pushNormal", "pushUv", "count", "pushTriangle", "Geometry", "faces", "faceVertexUvs", "MeshFaceMaterial", "morphTargets", "morphTargetInfluences", "materialIndex", "checkTriangleVisibility", "checkBackfaceCulling", "BackSide", "negate", "vertexNormals", "pushLine", "LineSegments", "VertexColors", "abs", "lerp",
    "use strict", "MeshBasicMaterial", "setValues", "oldColor", "oldOpacity", "highlight", "setRGB", "linewidth", "TransformGizmo", "handles", "pickers", "planes", "activePlane", "XYZE", "YZ", "XZ", "handleGizmos", "pickerGizmos", "updateMatrix", "applyMatrix", "E", "search", "lookAt", "setFromRotationMatrix", "X", "Y", "Z", "setFromEuler", "TransformGizmoTranslate", "merge", "setActivePlane", "XY", "extractRotation", "XYZ", "TransformGizmoRotate", "sin", "makeRotationFromQuaternion", "atan2", "setFromAxisAngle",
    "multiplyQuaternions", "TransformGizmoScale", "TransformControls", "translationSnap", "rotationSnap", "space", "world", "size", "axis", "change", "mouseDown", "mouseUp", "objectChange", "touchstart", "touchmove", "mouseout", "touchend", "touchcancel", "touchleave", "attach", "detach", "setMode", "local", "dispatchEvent", "setTranslationSnap", "setRotationSnap", "setSpace", "distanceTo", "button", "changedTouches", "stopPropagation", "setFromMatrixScale", "rotate", "cross", "angleTo", "mode", "cubeMesh",
    "textures", "resource/skybox/sky_0.jpg", "resource/skybox/sky_1.jpg", "resource/skybox/sky_5.jpg", "resource/skybox/sky_4.jpg", "resource/skybox/sky_3.jpg", "resource/skybox/sky_2.jpg", "loadSkyBox", "RGBFormat", "setFrontTexture", "setBackTexture", "setUpTexture", "setDownTexture", "setRightTexture", "setLiftTexture", "onSceneResize", "aspect", "updateProjectionMatrix", "CanvasRenderingContext2D", "WebGLRenderingContext", "webgl", "experimental-webgl", "Worker", "File", "FileReader", "FileList",
    "Blob", "webgl-error-message", "monospace", "13px", "#fff", "#000", "1.5em", "400px", "5em auto 0", 'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.', 'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', "oldie", "getWebGLErrorMessage",
    "depthTestUsed", "getType", "fontName", "STHeiti", "italic", "outlineVisible", "fillColor", "outlineColor", "strokeWidth", "setFontName", "setFontSize", "setFillColor", "setOutlineColor", "setStrokeWidth", "MarkerStyle", "iconColor", "iconSize", "iconVisible", "textVisible", "iconFixedSize", "textStyle", "setIconColor", "getIconPath", "setIconPath", "getIconScale", "iconScale", "setIconScale", "setStyle", "setTextStyle", "getTextStyle", "setIconVisible", "getIconVisible", "setTextVisible", "getTextVisible",
    "IconStyle", "getIconColor", "description", "getName", "getId", "GeoMarker", "strIconPath", "billboard", "needUpdate", "screenRect", "bIsNameVisble", "actualAspect", "setName", "postion", "getNameVisble", "controlCamera", "radius", "domElement", "controlRender", "applyQuaternion", "subVectors", "computeTowVecDist", "computeTowVecDistSquare", "computeDistFromEye", "Fs", "mulVec3Vec4", "isZeroVec2", "isZeroVec3", "computeSpherePixelSize", "computePixelSizeVector", "lengthSq", "GeoModel", "lengthComputable",
    "loaded", "total", "mtl", "preload", "castShadow", "receiveShadow", "computeBoundingSphere", "rotateX", "geometrys", "maxID", "curSendNode", "date", "lastTime", "getTime", "lastUpadeIndex", "attachObject", "removeAll", "GeoModelLOD", "addGeometry", "layer", "removeGeometryByName", "getGeometryByName", "removeGeometryByID", "getGeometryByID", "getGeometryByIndex", "GeoPolygon", "PageLOD", "nodeCount", "maxNodeCount", "strDataUrl", "loadStatus", "LS_UNLOAD", "sortNodes", "frustum", "viewPort", "matLocal",
    "matLocalInvert", "matModelView", "matVPW", "pixelSizeVector", "lastAccessFrame", "lastAccessTime", "maxHttpRequestNum", "curHttpRequestNum", "maxTexRequestNum", "curTexRequestNum", "maxNodeParseThreadNum", "curNodeParseThreadNum", "curLoadingNode", "bdSphere", "addNode", "pageLOD", "root", "getPixelSizeVector", "setPixelSizeVector", "getModelViewMatrix", "getFrustum", "getViewport", "setViewport", "setLastAccessTime", "getLastAccessTime", "setLastAccessFrame", "getLastAccessFrame", "addReleaseCount",
    "addNodeCount", "LS_LOADING", "responseXML", "ActiveXObject", "loadXML", "text/xml", "Scale", "getElementsByTagName", "Rotation", "OffsetMeters", "NodeList", "strDataPath", "LS_LOADED", "fromJson", "DataDefine", "Range", "Node", "addToDropList", "getLoadStatus", "computeNodeLevel", "findDropNode", "cleanRedundantNodes", "isGrandchildrenSafeDel", "unloadChildren", "computeFrustum", "distToEyeSquare", "imgUrl", "bImgBlobUrl", "PageLODNode", "childRanges", "bNormalRendered", "bInFrustumTestOk", "bdBox",
    "btLoadStatus", "enRangeMode", "bHasGeometry", "arryMaterials", "arryMaterialUsed", "dataBuffer", "dMemUsed", "setInFrustumTestOk", "isInFrustumTestOk", "setLoadStatus", "hasGeometry", "setHasGeometry", "revokeObjectURL", "minFilter", "magFilter", "netLoad", "responseType", "arraybuffer", "response", "script/lsjworker/LSJPWM.min.js", "onmessage", "bUrl", "imgBlob", "createObjectURL", "diffuseR", "diffuseG", "diffuseB", "Error:", "postMessage", "nodeMeshes", "verts", "matIndex", "indices", "colorPerNum",
    "checkInFrustum", "intersectsSphere", "intersectsBox", "computeDistSquare2Eye", "LS_NET_LOADED", "hasLoadingMaterial", "isAllMaterialLoaded", "calcNodeCount", "pop", "checkAllGroupChildLoaded", "RM_DISTANCE_FROM_EYE_POINT", "RM_PIXEL_SIZE_ON_SCREEN", "wireframe", "Wireframe", "splineHelperObjects", "splinePointsLength", "ARC_SEGMENTS", "NodeEdit", "transformControl", "delayHideTransform", "cancelHideTransorm", "hideTransform", "hiding", "clearTimeout", "points", "updateSplineOutline", "dragcontrols",
    "addSplineObject", "ambient", "addPoint", "removePoint", "mesh", "getPoint", "verticesNeedUpdate", "target", "delta", "theta", "FlyAroundCenter", "asin", "radToDeg", "degToRad", "order", "endPosition", "endHeading", "endPitch", "endRoll", "flyTo", "tube", "splineCamera", "binormal", "lookAhead", "toJSON", "duration", "lineString", "Tour", "\u7ebf\u8def\u4e00", "getPointAt", "parameters", "tangents", "binormals", "getTangentAt", "getLength", "isRemoved", "bClippingControl", "bDrawing", "point3ds",
    "spheres", "sphereGeometry", "addPoint3D", "setPoint3D", "clippingPlanes", "getWorldPosition", "fov", "updateDragging", "addMouseMoveListener", "buttons", "addLeftClickListener", "addDoubleClickListener", "createClippingPlanes", "light", "bTrack", "bTrackCamera", "shadowCameraLeft", "shadowCameraRight", "shadowCameraTop", "shadowCameraBottom", "shadowCameraNear", "shadowCameraFar", "shadowMapWidth", "shadowMapHeight", "shadowBias", "shadowMap", "cullFace", "CullFaceBack", "orbit", "up", "enableDamping",
    "dampingFactor", "enableZoom", "visble", "devicePixelRatio", "setPixelRatio", "autoUpdateScene", "autoClearColor", "addPass", "textures/tri_pattern.jpg", "resource/image/NaviCursor.png", "resize", "setClearAlpha", "vecZoomPos", "bZoomInertia", "nCurZoomTime", "dDeltaZoomRatio", "LEFT", "MOUSE", "RIGHT", "projectOnPlane", "vecPanDelta", "bPanInertia", "nCurPanTime", "dDeltaPanRatio", "bPitchInteria", "m_bMomentumZoom", "dZoomRadio", "vecRollPos", "m_bMomentumRoll", "dRotateAngle", "vecPitchPos", "m_bMomentumPitch",
    "dDeltaPitch", "bMomentumRoll", "bMomentumPitch", "bMomentumZoom", "dDeltaRollAngle", "bRollInertia", "nCurRollTime", "dDeltaTilt", "nCurPitchTime", "nTotalPanTime", "getInertiaRatio", "nTotalRollTime", "nTotalZoomTime", "nTotalPitchTime", "touches", "acos", "addSelectionObject", "Group", "Owner", "wheelDelta", "detail", "mousewheel", "contextmenu", "MozMousePixelScroll", "None", "Heightmap", "varying float height;", "void main() ", "{", "height = position.z;", "uniform vec2 colorRange;\n", "varying float height;\n",
    "void main()\n ", "{\n", "float halfRange = (colorRange.y - colorRange.x) * 0.5;", "float factor1 = clamp((height-colorRange.x) / halfRange, 0.0, 1.0);\n", "float factor2 = clamp((height-colorRange.x-halfRange) / halfRange, 0.0, 1.0);\n", "vec3 color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0), factor1);", "color = mix(color, vec3(1.0, 0.0, 0.0), factor2);", "gl_FragColor = vec4(color, 1.0);\n", "}\n", "HeightmapWireframe", "getMomentumSpeed", "MOMENTUM_ROLL", "MOMENTUM_PITCH", "MOMENTUM_ZOOM",
    "INERTIA_PAN", "INERTIA_ROLL", "bRollInteria", "INERTIA_PITCH", "INERTIA_ZOOM", "bZoomInteria", "renderLine", "renderPoints", "renderMarker", "geometryMaker", "geometryMakerV", "geometryMakerH", "lineSegMaterial", "bUpdate", "edgeLabels", "computeLineDistances", "Arial", "toFixed", "\u7c73", "setBorderColor", "setBackgroundColor", "setText", "getScene", "minDistance", "maxDistance", "minZoom", "maxZoom", "minPolarAngle", "maxPolarAngle", "minAzimuthAngle", "maxAzimuthAngle", "calPhiAndThetaAngle",
    "setFromUnitVectors", "getPolarAngle", "getAzimuthalAngle", "rotateLeft", "rotateUp", "panLeft", "panUp", "pan", "PerspectiveCamera", "OrthographicCamera", "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.", "dollyIn", "zoom", "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.", "dollyOut", "applyAxisAngle", "distanceToSquared", "OrbitControls", "constraint", "defineProperty", "zoomSpeed", "enableRotate", "rotateSpeed", "enablePan", "keyPanSpeed",
    "autoRotate", "autoRotateSpeed", "enableKeys", "keys", "mouseButtons", "MIDDLE", "NONE", "target0", "position0", "zoom0", "reset", "pow", "ORBIT", "ROTATE", "ZOOM", "PAN", "DOLLY", "UP", "BOTTOM", "keyCode", "TOUCH_ROTATE", "pageX", "pageY", "TOUCH_DOLLY", "TOUCH_PAN", "keydown", "THREE.OrbitControls: target is now immutable. Use target.set() instead.", "THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.", "THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.",
    "THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.", "THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.", "THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.", "THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.", "defineProperties", "sprite", "borderThickness", "fontface", "borderColor", "textColor", "getSprite", "setTextColor", "roundRect", "rgba(0, 0, 0, 1.0)", "lineTo", "quadraticCurveTo",
    "bTransparent", "imgUnits", "ModelLODNode", "model", "arryTextures", "arryTextureUsed", "bMap", "matrixWorldNeedsUpdate", "setMatrixWorldNeedsUpdate", ".pvr", "loadPVRTexture", ".dds", "loadDDSTexture", "LinearMipMapLinearFilter", "MirroredRepeatWrapping", "LinearMipMapNearestFilter", "anisotropy", "onprogress", "script/lsjworker/LSJLBMLoadWorker.js", "arryImages", "diffuse", "emission", "getRotate", "getScale", "compose", "rootNode", "union", "primitiveSets", "imgIndex", "isAllTextureLoaded", "hasLoadingTexture",
    "bUpadteMtl", "bSelect", "strModelPath", "setModelPath", "getModelPath", "setRotate", "setScale", "setSelect", "getBoundingBox", "selecttiongeometrys", "Features", "Feature", "Location", "Model", "Link", "pointSize", "sizeType", "Fixed", "pointSizeType", "FIXED", "PointSizeType", "pointColorType", "quality", "Squares", "heightMin", "heightMax", "setPointSize", "getPointSize", "setPointSizing", "Attenuated", "ATTENUATED", "Adaptive", "ADAPTIVE", "getPointSizing", "setQuality", "Interpolation", "isSupported",
    "SHADER_INTERPOLATION", "Splats", "SHADER_SPLATS", "getQuality", "setPointColorType", "toMaterialID", "getPointColorType", "toMaterialName", "RGB", "PointColorType", "COLOR", "Elevation", "HEIGHT", "Intensity", "INTENSITY", "Intensity Gradient", "INTENSITY_GRADIENT", "Classification", "CLASSIFICATION", "Return Number", "RETURN_NUMBER", "Source", "SOURCE", "Tree Depth", "TREE_DEPTH", "Point Index", "POINT_INDEX", "Normal", "NORMAL", "Phong", "PHONG", "setHeightRange", "getHeightRange", "pointcloud",
    "PointShape", "CIRCLE", "POCLoader", "labelSize", "element", "setVerticalOrign", "getVerticalOrign", "getHorizontalOrigin", "setHorizontalOrigin", "setLabelElement", "loading"];

module.exports= _0x34b6